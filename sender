# -*- coding: utf-8 -*-
# Python 2.7
# Sender logic (variables/process aligned with your original VideoSender; no real sockets)

from link import Data

class VideoSender(object):
    def __init__(self, sim, link_fwd, link_rev, mss=1200):
        # Simulator and links
        self.sim = sim
        self.link_fwd = link_fwd
        self.link_rev = link_rev

        # ===== Core state aligned with original VideoSender =====
        self.init_ts = 0                           # start time = 0 (simulated clock)
        self.seq_num = 0                           # next sequence number to send
        self.next_ack = 0                          # oldest unacknowledged sequence
        self.cwnd = 2.0                            # congestion window
        self.ssthresh = 64.0                       # slow start threshold (added: for AIMD)
        self.step_len_ms = 100                     # similar to original, placeholder only

        # BBR/Vegas variables simplified; keep names for possible RL extension
        self.delivered_time = 0
        self.delivered = 0
        self.sent_bytes = 0

        # RTT/RTO (names consistent with original)
        self.srtt = None
        self.rttvar = None
        self.rto = 1000                            # initial RTO 1s
        self.rto_recovery = {}                     # mark packets in RTO recovery
        self.retransmit_flags = {}                 # mark retransmitted packets (Karn)
        self.ack_counts = {}                       # duplicate ACK count (key=ack_seq)
        self.sent_packets = {}                     # sent but unacked: seq -> {'data':Data,'send_time':ms,'rto':ms}

        # Others
        self.mss = int(mss)
        self.running = True

        # Periodic tick: check timeout and try to send packets
        self.sim.schedule(0, 'sender_tick', {})

    # ===== Time and window =====
    def curr_ts_ms(self):
        return int(self.sim.time_ms)

    def can_send(self):
        in_flight = self.seq_num - self.next_ack
        return in_flight < self.cwnd

    def window_is_open(self):
        return self.can_send()

    # ===== Sending =====
    def send(self):
        if not self.can_send():
            return
        data = Data(
            seq_num=self.seq_num,
            send_ts=self.curr_ts_ms(),
            sent_bytes=self.mss,
            delivered_time=self.delivered_time,
            delivered=self.delivered,
            payload=""
        )
        self.link_fwd.send(self.sim, self.curr_ts_ms(), 'to_receiver', 'data', data)

        self.sent_packets[self.seq_num] = {
            'data': data,
            'send_time': self.curr_ts_ms(),
            'rto': self.rto
        }
        self.seq_num += 1
        self.sent_bytes += self.mss

    def maybe_fill_window(self):
        while self.window_is_open():
            self.send()

    # ===== ACK processing (aligned with original logic) =====
    def update_state(self, ack):
        curr_time_ms = self.curr_ts_ms()
        acked_seq = ack.seq_num

        if acked_seq >= self.next_ack:
            # Normal cumulative ACK, advance window
            self.next_ack = acked_seq + 1

            # Clear duplicate ACK counts (for confirmed seq and earlier)
            keys_to_del = [k for k in self.ack_counts if k <= acked_seq]
            for k in keys_to_del:
                del self.ack_counts[k]

            # Clear confirmed packets
            keys_to_del = [k for k in self.sent_packets if k <= acked_seq]
            for k in keys_to_del:
                # RTT update (Karn: only for first transmissions)
                info = self.sent_packets[k]
                is_retx = self.retransmit_flags.get(k, False)
                if (not is_retx) and (ack.send_ts == info['data'].send_ts):
                    rtt = curr_time_ms - info['send_time']
                    self._update_rto(rtt)
                # Delete this seq
                del self.sent_packets[k]
                if k in self.retransmit_flags:
                    del self.retransmit_flags[k]
                if k in self.rto_recovery:
                    del self.rto_recovery[k]

            # Congestion control (slow start / AIMD; can be replaced with RL)
            if self.cwnd < self.ssthresh:
                self.cwnd += 1.0
            else:
                self.cwnd += 1.0 / max(1.0, self.cwnd)

        else:
            # Out-of-order/duplicate ACK
            self.ack_counts[acked_seq] = self.ack_counts.get(acked_seq, 0) + 1
            if self.ack_counts[acked_seq] == 3:
                # Fast retransmit: retransmit next_ack
                self.fast_retransmit(self.next_ack)

        # Try to send more
        self.maybe_fill_window()

    def fast_retransmit(self, seq_num):
        if seq_num not in self.sent_packets:
            return
        pkt_info = self.sent_packets[seq_num]
        data = pkt_info['data']
        # Mark as retransmitted, Karn skips RTT update
        self.retransmit_flags[seq_num] = True
        self.link_fwd.send(self.sim, self.curr_ts_ms(), 'to_receiver', 'data', data)
        self.sent_packets[seq_num]['send_time'] = self.curr_ts_ms()

        # Congestion control: multiplicative decrease
        self.ssthresh = max(2.0, self.cwnd / 2.0)
        self.cwnd = max(2.0, self.ssthresh + 3.0)  # fast recovery approx

    # ===== Timeout retransmission (check oldest unacked only) =====
    def check_timeout_retransmission(self):
        now = self.curr_ts_ms()
        seq = self.next_ack
        pkt_info = self.sent_packets.get(seq)
        if pkt_info is not None and (now - pkt_info['send_time'] > pkt_info['rto']):
            # Timeout retransmit
            data = pkt_info['data']
            self.link_fwd.send(self.sim, now, 'to_receiver', 'data', data)
            self.sent_packets[seq]['send_time'] = now

            self.retransmit_flags[seq] = True
            self.rto_recovery[seq] = True

            # Exponential backoff and congestion control fallback
            self.rto = min(self.rto * 2, 60000)
            self.ssthresh = max(2.0, self.cwnd / 2.0)
            self.cwnd = 1.0

    # ===== RTO/SRTT/RTTVAR update (names aligned with original) =====
    def _update_rto(self, rtt):
        rtt = float(rtt)
        if self.srtt is None:
            self.srtt = rtt
            self.rttvar = self.srtt / 2.0
        else:
            self.rttvar = 0.75 * self.rttvar + 0.25 * abs(self.srtt - rtt)
            self.srtt = 0.875 * self.srtt + 0.125 * rtt
        self.rto = int(max(self.srtt + 4.0 * self.rttvar + 0.5, 200.0))

    # ===== Periodic driver (replaces original single_step/poll loop) =====
    def on_tick(self):
        self.check_timeout_retransmission()
        self.maybe_fill_window()
        # Next tick (10ms)
        self.sim.schedule(self.sim.time_ms + 10, 'sender_tick', {})
