å¥½çš„ï¼Œæˆ‘ä»¬å°†åŸºäºä½ ä¹‹å‰çš„è®¾è®¡ç†å¿µï¼Œä½¿ç”¨ çº¯ Python + UDP åè®® + æ¨¡æ‹Ÿé€»è¾‘ å®ç°ä¸€ä¸ª TCP åè®®ä»¿çœŸæ¡†æ¶ï¼Œå…¶ç‰¹ç‚¹ä¸ºï¼š
	â€¢	ä¸å®é™…å‘é€ç½‘ç»œæ•°æ®åŒ…ï¼ˆå³ä¸ä½¿ç”¨ socket.sendto()ï¼‰
	â€¢	ä»…æ¨¡æ‹Ÿæ•°æ®åŒ…çš„å‘é€ã€å»¶è¿Ÿã€ç¡®è®¤ã€é‡ä¼ ç­‰è¿‡ç¨‹
	â€¢	æ¨¡æ‹Ÿ RTTã€RTOã€ACKã€ä¸¢åŒ…ã€çª—å£ç­‰ TCP æœºåˆ¶
	â€¢	å¯ä»¥ä½œä¸ºä½ RL/TCPç®—æ³•çš„ç¦»çº¿è°ƒè¯•æˆ–ç®—æ³•åŸå‹ç¯å¢ƒ

â¸»

âœ… æ¨¡æ‹Ÿæ¡†æ¶ç»“æ„

æ¨¡å—	åŠŸèƒ½
Sender	æ¨¡æ‹Ÿå‘é€çª—å£ã€RTO è¶…æ—¶ã€ACKå“åº”ç­‰
Receiver	æ¨¡æ‹ŸACKç”Ÿæˆã€é¡ºåºæ§åˆ¶ã€ACKå»¶è¿Ÿ
NetworkSim	æ§åˆ¶é“¾è·¯å»¶è¿Ÿã€ä¸¢åŒ…ã€æ•°æ®åœ¨é“¾è·¯ä¸­è½¬å‘


â¸»

ğŸ“ æ–‡ä»¶ç»“æ„ï¼ˆå•ä¸ªæ–‡ä»¶å¯è¿è¡Œï¼‰

# simulate_tcp.py


â¸»

âœ… æ¨¡æ‹Ÿé…ç½®å‚æ•°ï¼ˆå…¨å±€ï¼‰

import time
import random
import heapq

# æ¨¡æ‹Ÿé…ç½®
SIM_TIME = 5000           # æ¨¡æ‹Ÿæ€»æ—¶é—´(ms)
RTT_BASE = 100            # åŸºæœ¬ RTT(ms)
DELAY_JITTER = 30         # æŠ–åŠ¨èŒƒå›´(+/-)
LOSS_RATE = 0.1           # ä¸¢åŒ…æ¦‚ç‡
MAX_SEQ = 1000            # æœ€å¤§æ¨¡æ‹Ÿåºå·
INIT_RTO = 200            # åˆå§‹ RTO
CWND_INIT = 3             # åˆå§‹çª—å£
SEND_INTERVAL = 50        # æ¯ä¸ªåŒ…å‘é€é—´éš”(ms)


â¸»

ğŸ§  æ¨¡æ‹Ÿç½‘ç»œï¼šNetworkSimulator

class NetworkSimulator:
    def __init__(self):
        self.event_queue = []  # ä½¿ç”¨å°æ ¹å †æ¨¡æ‹Ÿè°ƒåº¦é˜Ÿåˆ—

    def send(self, delay_ms, callback, *args):
        """å°†äº‹ä»¶åŠ å…¥äº‹ä»¶é˜Ÿåˆ—ï¼ˆæ¨¡æ‹ŸåŒ…åœ¨é“¾è·¯ä¸Šï¼‰"""
        event_time = current_time + delay_ms
        heapq.heappush(self.event_queue, (event_time, callback, args))

    def run(self):
        global current_time
        while self.event_queue and current_time <= SIM_TIME:
            event_time, callback, args = heapq.heappop(self.event_queue)
            current_time = event_time
            callback(*args)


â¸»

ğŸ“¤ æ¨¡æ‹Ÿå‘é€ç«¯ï¼šSender

class Sender:
    def __init__(self, receiver, net):
        self.receiver = receiver
        self.net = net
        self.seq_num = 0
        self.unacked = {}  # {seq_num: (send_ts, rto)}
        self.cwnd = CWND_INIT
        self.rto = INIT_RTO
        self.srtt = None
        self.rttvar = None
        self.timer = None

    def send_data(self):
        while len(self.unacked) < self.cwnd and self.seq_num < MAX_SEQ:
            seq = self.seq_num
            self.seq_num += 1
            send_ts = current_time
            self.unacked[seq] = (send_ts, self.rto)
            print(f"[{current_time} ms] Send packet {seq}")

            # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ & ä¸¢åŒ…
            if random.random() > LOSS_RATE:
                delay = RTT_BASE / 2 + random.randint(-DELAY_JITTER, DELAY_JITTER)
                self.net.send(delay, self.receiver.receive, seq, send_ts, self)

            # å®‰æ’è¶…æ—¶é‡ä¼ äº‹ä»¶
            self.net.send(self.rto, self.timeout_retransmit, seq)

    def receive_ack(self, ack_seq, ack_ts):
        if ack_seq in self.unacked:
            send_ts, _ = self.unacked.pop(ack_seq)
            rtt = current_time - send_ts
            print(f"[{current_time} ms] ACK {ack_seq} received, RTT = {rtt} ms")

            # RTTä¼°è®¡ & RTOè°ƒæ•´ï¼ˆRFC6298ï¼‰
            if self.srtt is None:
                self.srtt = rtt
                self.rttvar = rtt / 2
            else:
                self.rttvar = 0.75 * self.rttvar + 0.25 * abs(self.srtt - rtt)
                self.srtt = 0.875 * self.srtt + 0.125 * rtt
            self.rto = int(self.srtt + 4 * self.rttvar)
            self.rto = max(self.rto, 100)

        self.send_data()  # ç»§ç»­å¡«æ»¡çª—å£

    def timeout_retransmit(self, seq):
        if seq in self.unacked:
            print(f"[{current_time} ms] Timeout for packet {seq}, RTO = {self.rto} ms")
            send_ts = current_time
            self.unacked[seq] = (send_ts, self.rto)
            if random.random() > LOSS_RATE:
                delay = RTT_BASE / 2 + random.randint(-DELAY_JITTER, DELAY_JITTER)
                self.net.send(delay, self.receiver.receive, seq, send_ts, self)
            self.net.send(self.rto, self.timeout_retransmit, seq)


â¸»

ğŸ“¥ æ¨¡æ‹Ÿæ¥æ”¶ç«¯ï¼šReceiver

class Receiver:
    def __init__(self, net):
        self.net = net
        self.expected_seq = 0

    def receive(self, seq, send_ts, sender):
        if seq == self.expected_seq:
            print(f"[{current_time} ms] Receiver got expected seq {seq}")
            self.expected_seq += 1
        else:
            print(f"[{current_time} ms] Receiver got out-of-order seq {seq} (expecting {self.expected_seq})")

        # å›ACKï¼ˆæ¨¡æ‹Ÿ ACK å»¶è¿Ÿ + ä¸ä¸¢åŒ…ï¼‰
        ack_delay = RTT_BASE / 2 + random.randint(-DELAY_JITTER, DELAY_JITTER)
        self.net.send(ack_delay, sender.receive_ack, seq, send_ts)


â¸»

â–¶ï¸ ä¸»å‡½æ•°è¿è¡Œå…¥å£

if __name__ == "__main__":
    current_time = 0  # å…¨å±€æ¨¡æ‹Ÿæ—¶é—´(ms)

    net = NetworkSimulator()
    receiver = Receiver(net)
    sender = Sender(receiver, net)

    # å¯åŠ¨åˆå§‹å‘é€
    net.send(0, sender.send_data)

    # æ¨¡æ‹Ÿä¸»å¾ªç¯
    net.run()


â¸»

âœ… è¾“å‡ºç¤ºä¾‹ï¼ˆéƒ¨åˆ†ï¼‰

[0 ms] Send packet 0
[0 ms] Send packet 1
[0 ms] Send packet 2
[54 ms] Receiver got expected seq 0
[105 ms] ACK 0 received, RTT = 105 ms
[105 ms] Send packet 3
...
[371 ms] Timeout for packet 2, RTO = 260 ms
[426 ms] ACK 1 received, RTT = 140 ms


â¸»

âœ… æ€»ç»“ï¼šè¯¥æ¨¡æ‹Ÿå…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹

ç‰¹æ€§	çŠ¶æ€
RTT & RTO	âœ” æ¨¡æ‹Ÿæ›´æ–°
Delay æŠ–åŠ¨	âœ” éšæœºå»¶è¿Ÿ
Packet Loss	âœ” ä¸¢åŒ…æ¨¡æ‹Ÿ
Fast Retrans	âŒï¼ˆå¯æ‰©å±•ï¼‰
Sliding cwnd	âœ” å‘é€çª—å£
é‡ä¼ è®¡æ—¶å™¨	âœ” per-packet


â¸»

æ˜¯å¦éœ€è¦æˆ‘ï¼š
	â€¢	âœï¸ åŠ å…¥é‡å¤ ACK å’Œå¿«é€Ÿé‡ä¼ æœºåˆ¶ï¼Ÿ
	â€¢	ğŸ§ª åŠ å…¥ throughput / loss rate çš„å®æ—¶è¯„ä¼°è¾“å‡ºï¼Ÿ
	â€¢	ğŸ“ ä¿å­˜ä¸º CSV åšå¯è§†åŒ–åˆ†æï¼Ÿ

å‘Šè¯‰æˆ‘ä½ çš„ä¸‹ä¸€æ­¥ç›®æ ‡ï¼Œæˆ‘å¯ä»¥ç»§ç»­ä¼˜åŒ–è¿™ä¸ªæ¨¡æ‹Ÿå™¨ã€‚
